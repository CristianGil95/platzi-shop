import { AkitaFilter, AkitaFiltersStore } from './akita-filters-store';
import { AkitaFiltersQuery } from './akita-filters-query';
import { Observable } from 'rxjs';
import { EntityCollectionPlugin, EntityState, EntityStore, getEntityType, getIDType, HashMap, ID, OrArray, QueryEntity, SelectAllOptionsA, SelectAllOptionsB, SelectAllOptionsC, SelectAllOptionsD, SelectAllOptionsE, SortByOptions } from '@datorama/akita';
export interface FiltersParams<S extends EntityState> {
    filtersStoreName?: string;
    entityIds?: OrArray<getIDType<S>>;
    [key: string]: any;
}
interface NormalizedFilterOptions {
    withSort?: boolean;
    asQueryParams?: boolean;
    sortByKey?: string;
    sortByOrderKey?: string;
}
export declare class AkitaFiltersPlugin<S extends EntityState, E = getEntityType<S>, I = OrArray<getIDType<S>>, P = any> extends EntityCollectionPlugin<S, P> {
    protected query: QueryEntity<S>;
    private params;
    private readonly _filtersStore;
    private readonly _filtersQuery;
    private _server;
    private _selectFilters$;
    private readonly _selectSortBy$;
    private readonly _selectFiltersAll$;
    constructor(query: QueryEntity<S>, params?: FiltersParams<S>);
    readonly filtersStore: AkitaFiltersStore<S>;
    readonly filtersQuery: AkitaFiltersQuery<S>;
    /**
     *  Add support of filters from server. Provide a function that will be call each time a filter changes
     *
     *  new AkitaFilterPlugins(query).withServer((filters) => {
     *      return this.api.getData(filters);
     *  });
     *
     *  Return false to not add in store. if you want to manage the store in your own.
     */
    withServer(onChangeFilter: (filtersNormalized: string | HashMap<any>) => any | boolean, options?: NormalizedFilterOptions): AkitaFiltersPlugin<S, E, I, P>;
    /** Return true, if server is configured **/
    hasServer(): boolean;
    /**
     *  Select all filters
     *
     *  Note: Only all filters not hided (with hide=true), will not be displayed. If you want it, call directly to:
     * `this.filtersQuery.selectAll()`
     *
     *
     */
    selectFilters(): Observable<AkitaFilter<S>[]>;
    /**
     * Get all the current snapshot filters
     *
     *  Note: filters with hide=true, will not be displayed. If you want it, call directly to:
     * `this.filtersQuery.getAll()`
     */
    getFilters(): AkitaFilter<S>[];
    /**
     * Get all the current snapshot server filters (only if server is available else return default not hidden filters)
     *
     *  Note: filters with server=false, will not be displayed. If you want it, call directly to:
     * `this.filtersQuery.getAll()`
     */
    getServerFilters(): AkitaFilter<S>[];
    /**
     * Select All Entity with apply filter to it, and updated with any change (entity or filter)
     * Will not apply sort, if need return   asObject:true !
     */
    selectAllByFilters(options?: SelectAllOptionsA<E> | SelectAllOptionsB<E> | SelectAllOptionsC<E> | SelectAllOptionsD<E> | SelectAllOptionsE<E> | any): Observable<getEntityType<S>[] | HashMap<getEntityType<S>>>;
    /**
     * Create or update a filter
     */
    setFilter(filter: Partial<AkitaFilter<S>>): void;
    /**
     * Remove a Filter
     */
    removeFilter(id: ID): void;
    /**
     * Clear all filters
     */
    clearFilters(): void;
    /**
     * Get filter value, return null, if value not available
     */
    getFilterValue<T = any>(id: string): T | null;
    /**
     * Get filter value, return null, if value not available
     */
    getSortValue(): SortByOptions<E> | null;
    /**
     * Select Sort by value
     */
    selectSortBy(): Observable<SortByOptions<E> | null>;
    /**
     * Set orderBy
     */
    setSortBy(order: SortByOptions<E>): void;
    /**
     * Get the filters normalized as key value or as query params.
     * This can be useful for server-side filtering
     */
    getNormalizedFilters(options?: NormalizedFilterOptions): string | HashMap<any>;
    destroy(): void;
    /** This method is responsible for getting access to the query. */
    protected getQuery(): QueryEntity<S>;
    /** This method is responsible for getting access to the store. */
    protected getStore(): EntityStore<S>;
    private _serialize;
    private _applyFiltersForArray;
    private _applyFiltersForHashMap;
    private _applyFiltersForOneEntity;
    protected instantiatePlugin(id: I): P;
}
export {};
