import { DataSource } from '@angular/cdk/table';
import { Observable, Subscription } from 'rxjs';
import { EntityState, getEntityType, ID, QueryEntity } from '@datorama/akita';
import { AkitaFilter } from '../akita-filters-store';
import { AkitaFiltersPlugin } from '../akita-filters-plugin';
import { MatSort } from '@angular/material/sort';
import { MatPaginator } from '@angular/material/paginator';
export declare class AkitaMatDataSource<S extends EntityState = any, E = getEntityType<S>> extends DataSource<E> {
    /**
     * Data source to use an Akita EntityStore with a Material table
     * @see : https://material.angular.io/components/table/overview
     *
     * @param query string : [Mandatory] the akita Query Entity, you wan to use to this data source.
     * @param akitaFilters string [Optional] If you want to provide an AkitaFilters that you use externally. Else it will create a new one.
     */
    constructor(query: QueryEntity<getEntityType<S>> | any, akitaFilters?: AkitaFiltersPlugin<S, E>);
    /**
     * @param searchQuery teh string use to search
     */
    filter: string;
    /**
     * filter all the list by a search term.
     *
     * use like a property :
     * akitaMatDataSourceInstance.search = 'term';
     * @param searchQuery the string use to search
     */
    search: string;
    /**
     * Instance of the MatSort directive used by the table to control its sorting. Sort changes
     * emitted by the MatSort will trigger an update to the table's rendered data.
     */
    sort: MatSort;
    /**
     * Instance of the MatPaginator component used by the table to control what page of the data is
     * displayed. Page changes emitted by the MatPaginator will trigger an update to the
     * table's rendered data.
     *
     * Note that the data source uses the paginator's properties to calculate which page of data
     * should be displayed. If the paginator receives its properties as template inputs,
     * e.g. `[pageLength]=100` or `[pageIndex]=1`, then be sure that the paginator's view has been
     * initialized before assigning it to this data source.
     */
    paginator: MatPaginator;
    /**
     * @deprecated use get akitaFiltersPlugin
     */
    readonly AkitaFilters: AkitaFiltersPlugin<S, E, any>;
    /**
     * Access to AkitaFiltersPlugins, usefull to interact with all filters
     */
    readonly akitaFiltersPlugIn: AkitaFiltersPlugin<S, E>;
    private _dataQuery;
    private readonly _filters;
    /** if set a custom filter plugins, do not delete all in disconnect() **/
    private _hasCustomFilters;
    private _paginator;
    private _sort;
    private _selectAllByFilter$;
    private _count$;
    /** Used to react to internal changes of the paginator that are made by the data source itself. */
    private readonly _internalPageChanges;
    /** Stream emitting render data to the table (depends on ordered data changes). */
    private readonly _renderData;
    /** Used to react to internal changes of the paginator that are made by the data source itself. */
    private readonly _disconnect;
    /**
     * Subscription to the changes that should trigger an update to the table's rendered rows, such
     * as filtering, sorting, pagination, or base data changes.
     */
    _renderChangesSubscription: Subscription;
    private _updateCount;
    /**
     * Paginate the data (client-side). If you're using server-side pagination,
     * this would be replaced by requesting the appropriate data from the server.
     */
    private _pageData;
    /**
     *  add a filter to filters plugins
     */
    addFilter(filter: Partial<AkitaFilter<S>>): void;
    /**
     *  add a filter to filters plugins
     */
    setFilter(filter: Partial<AkitaFilter<S>>): void;
    /**
     * Remove a AkitaFilter
     */
    removeFilter(id: ID): void;
    /**
     * Clear all filters
     */
    clearFilters(): void;
    /**
     * Get filter value, return null, if value not available
     */
    getFilterValue<V = E>(id: string): V | null;
    /**
     * Set the default sort
     * @param sortColumn the colum name present in your object
     * @param direction string the direction for sorting (asc or desc). Default asc.
     */
    setDefaultSort(sortColumn: keyof E, direction?: 'asc' | 'desc'): void;
    /**
     * Select Count filtered results.
     */
    selectCount(): Observable<number>;
    /**
     * Select Count filtered results.
     */
    getCount(): number;
    /**
     * Subscribe to changes that should trigger an update to the table's rendered rows. When the
     * changes occur, process the current state of the filter, sort, and pagination along with
     * the provided base data and send it to the table for rendering.
     */
    _updateChangeSubscription(): void;
    /**
     * Updates the paginator to reflect the length of the filtered data, and makes sure that the page
     * index does not exceed the paginator's last page. Values are changed in a resolved promise to
     * guard against making property changes within a round of change detection.
     */
    _updatePaginator(filteredDataLength: number): void;
    /**
     * Function used by matTable to subscribe to the data
     */
    connect(): Observable<E[]>;
    /**
     * Used by the MatTable. Called when it is destroyed. No-op.
     * @docs-private
     */
    disconnect(): void;
}
