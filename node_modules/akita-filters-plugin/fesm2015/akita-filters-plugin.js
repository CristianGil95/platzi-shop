import { __decorate, __metadata } from 'tslib';
import { isObject, isString, isDefined, guid, EntityStore, StoreConfig, QueryEntity, QueryConfig, Order, EntityCollectionPlugin, isUndefined, isFunction, compareValues } from '@datorama/akita';
import { merge, isObservable, combineLatest, Subject, BehaviorSubject, Subscription, of } from 'rxjs';
import { map, takeUntil } from 'rxjs/operators';
import { DataSource } from '@angular/cdk/table';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Helper function to do a default filter
 * @template E, S
 * @param {?} value
 * @param {?} index
 * @param {?} array
 * @param {?} filter
 * @return {?}
 */
function defaultFilter(value, index, array, filter) {
    if (isObject(value) && isString(filter.value)) {
        return searchFilter(filter.value, value);
    }
    return isDefined(filter.value) ? filter.value === value : !!value;
}
/**
 * Helper function to do search on all string element
 * @param {?} searchKey
 * @param {?} inObj
 * @return {?}
 */
function searchFilter(searchKey, inObj) {
    return isString(searchKey) && Object.keys(inObj).some((/**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return isString(inObj[key]) && inObj[key].toLocaleLowerCase().includes(searchKey.toLocaleLowerCase());
    }));
}
/**
 * Helper function to do search in one key of an object
 * @param {?} searchKey
 * @param {?} inObj
 * @param {?} inKey
 * @return {?}
 */
function searchFilterIn(searchKey, inObj, inKey) {
    return isString(searchKey)
        && isString(inKey)
        && isString(inObj[inKey])
        && inObj[inKey].toLocaleLowerCase().includes(searchKey.toLocaleLowerCase());
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} str
 * @return {?}
 */
function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.substr(1);
}
/**
 * @record
 * @template S, E
 */
function AkitaFilter() { }
if (false) {
    /** @type {?} */
    AkitaFilter.prototype.id;
    /**
     * A corresponding name for display the filter, by default, it will be ${id): ${value}
     * @type {?|undefined}
     */
    AkitaFilter.prototype.name;
    /**
     * set the order for filter, by default, it is 10
     * @type {?|undefined}
     */
    AkitaFilter.prototype.order;
    /**
     * The filter value, this will be used to compute name, or getting the current value, to initiate your form
     * @type {?|undefined}
     */
    AkitaFilter.prototype.value;
    /**
     * If you want to have filter that is not displayed on the list
     * @type {?|undefined}
     */
    AkitaFilter.prototype.hide;
    /**
     * If you have enabled server filter, specify witch filters will be call to server, default to false.
     * @type {?|undefined}
     */
    AkitaFilter.prototype.server;
    /**
     * The function to apply filters, by default use defaultFilter helpers, that will search the value in the object
     * @type {?}
     */
    AkitaFilter.prototype.predicate;
    /* Skipping unhandled member: [key: string]: any;*/
}
/**
 * @template S, E
 * @param {?} filterParams
 * @return {?}
 */
function createFilter(filterParams) {
    /** @type {?} */
    const id = filterParams.id ? filterParams.id : guid();
    /** @type {?} */
    const name = filterParams.name || (filterParams.value && filterParams.id ?
        `${capitalize(filterParams.id.toString())}: ${filterParams.value.toString()}` : undefined);
    if (!filterParams.predicate && filterParams.value) {
        /** use default function, if not provided */
        // @ts-ignore
        filterParams.predicate = defaultFilter;
    }
    return (/** @type {?} */ (Object.assign({ id, name, hide: false, order: 10, server: false }, filterParams)));
}
/**
 * @record
 * @template S, E
 */
function FiltersState() { }
if (false) {
    /** @type {?} */
    FiltersState.prototype.sort;
}
/**
 * @template S
 */
let AkitaFiltersStore = /**
 * @template S
 */
class AkitaFiltersStore extends EntityStore {
    /**
     * @param {?} storeName
     */
    constructor(storeName) {
        super(undefined, { name: storeName });
    }
};
AkitaFiltersStore.ctorParameters = () => [
    { type: String }
];
/**
 * @template S
 */
AkitaFiltersStore = __decorate([
    StoreConfig({ name: 'filters' }),
    __metadata("design:paramtypes", [String])
], AkitaFiltersStore);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template S
 */
let AkitaFiltersQuery = /**
 * @template S
 */
class AkitaFiltersQuery extends QueryEntity {
    /**
     * @param {?} store
     */
    constructor(store) {
        super(store);
        this.store = store;
    }
};
AkitaFiltersQuery.ctorParameters = () => [
    { type: AkitaFiltersStore }
];
/**
 * @template S
 */
AkitaFiltersQuery = __decorate([
    QueryConfig({
        sortBy: 'order',
        sortByOrder: Order.ASC
    }),
    __metadata("design:paramtypes", [AkitaFiltersStore])
], AkitaFiltersQuery);
if (false) {
    /**
     * @type {?}
     * @protected
     */
    AkitaFiltersQuery.prototype.store;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 * @template S
 */
function FiltersParams() { }
if (false) {
    /** @type {?|undefined} */
    FiltersParams.prototype.filtersStoreName;
    /** @type {?|undefined} */
    FiltersParams.prototype.entityIds;
    /* Skipping unhandled member: [key: string]: any;*/
}
/**
 * @record
 */
function NormalizedFilterOptions() { }
if (false) {
    /** @type {?|undefined} */
    NormalizedFilterOptions.prototype.withSort;
    /** @type {?|undefined} */
    NormalizedFilterOptions.prototype.asQueryParams;
    /** @type {?|undefined} */
    NormalizedFilterOptions.prototype.sortByKey;
    /** @type {?|undefined} */
    NormalizedFilterOptions.prototype.sortByOrderKey;
}
/**
 * @template S, E, I, P
 */
class AkitaFiltersPlugin extends EntityCollectionPlugin {
    /**
     * @param {?} query
     * @param {?=} params
     */
    constructor(query, params = {}) {
        super(query, params.entityIds);
        this.query = query;
        this.params = params;
        this._server = false;
        this.params = Object.assign({ filtersStoreName: this.getStore().storeName + 'Filters' }, params);
        this._filtersStore = new AkitaFiltersStore(this.params.filtersStoreName);
        this._filtersQuery = new AkitaFiltersQuery(this._filtersStore);
        this._selectFilters$ = this.filtersQuery.selectAll({ sortBy: 'order' });
        this._selectFiltersAll$ = this.filtersQuery.selectAll({ sortBy: 'order', filterBy: (/**
             * @param {?} filter
             * @return {?}
             */
            filter => !filter.hide) });
        this._selectSortBy$ = this.filtersQuery.select((/**
         * @param {?} state
         * @return {?}
         */
        state => state && state.sort ? state.sort : null));
    }
    /**
     * @return {?}
     */
    get filtersStore() {
        return this._filtersStore;
    }
    /**
     * @return {?}
     */
    get filtersQuery() {
        return this._filtersQuery;
    }
    /**
     *  Add support of filters from server. Provide a function that will be call each time a filter changes
     *
     *  new AkitaFilterPlugins(query).withServer((filters) => {
     *      return this.api.getData(filters);
     *  });
     *
     *  Return false to not add in store. if you want to manage the store in your own.
     * @param {?} onChangeFilter
     * @param {?=} options
     * @return {?}
     */
    withServer(onChangeFilter, options = {}) {
        this._server = true;
        // Change default select filters to remove server filters, if you use selectAllByFilters();
        this._selectFilters$ = this._filtersQuery.selectAll({ sortBy: 'order', filterBy: (/**
             * @param {?} filter
             * @return {?}
             */
            filter => !filter.server) });
        /** @type {?} */
        const listObservable = [];
        listObservable.push(this._filtersQuery.selectAll({ sortBy: 'order', filterBy: (/**
             * @param {?} filter
             * @return {?}
             */
            filter => filter.server) }));
        if (options.withSort) {
            listObservable.push(this.selectSortBy());
        }
        merge(listObservable).subscribe((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const returnOnChange = onChangeFilter(this.getNormalizedFilters(options));
            if (returnOnChange !== false && isObservable(returnOnChange)) {
                returnOnChange.subscribe((/**
                 * @param {?} newValue
                 * @return {?}
                 */
                (newValue) => {
                    this.getStore().set(newValue);
                }));
            }
        }));
        return this;
    }
    /**
     * Return true, if server is configured *
     * @return {?}
     */
    hasServer() {
        return this._server;
    }
    /**
     *  Select all filters
     *
     *  Note: Only all filters not hided (with hide=true), will not be displayed. If you want it, call directly to:
     * `this.filtersQuery.selectAll()`
     *
     *
     * @return {?}
     */
    selectFilters() {
        return this._selectFiltersAll$;
    }
    /**
     * Get all the current snapshot filters
     *
     *  Note: filters with hide=true, will not be displayed. If you want it, call directly to:
     * `this.filtersQuery.getAll()`
     * @return {?}
     */
    getFilters() {
        return this._filtersQuery.getAll({ filterBy: (/**
             * @param {?} filter
             * @return {?}
             */
            filter => !filter.hide) });
    }
    /**
     * Get all the current snapshot server filters (only if server is available else return default not hidden filters)
     *
     *  Note: filters with server=false, will not be displayed. If you want it, call directly to:
     * `this.filtersQuery.getAll()`
     * @return {?}
     */
    getServerFilters() {
        return this._server ? this._filtersQuery.getAll({ filterBy: (/**
             * @param {?} filter
             * @return {?}
             */
            filter => !filter.server) }) : this.getFilters();
    }
    /**
     * Select All Entity with apply filter to it, and updated with any change (entity or filter)
     * Will not apply sort, if need return   asObject:true !
     * @param {?=} options
     * @return {?}
     */
    selectAllByFilters(options) {
        if (options && options.asObject) {
            return combineLatest(this._selectFilters$, this.getQuery().selectAll(options)).pipe(map((/**
             * @param {?} __0
             * @return {?}
             */
            ([filters, entities]) => {
                /** @type {?} */
                const unkNowEntity = entities;
                return this._applyFiltersForHashMap(((/** @type {?} */ (unkNowEntity))), filters);
            })));
        }
        else {
            return combineLatest(this._selectFilters$, this.getQuery().selectAll(options), this.selectSortBy()).pipe(map((/**
             * @param {?} __0
             * @return {?}
             */
            ([filters, entities, sort]) => {
                /** @type {?} */
                const unkNowEntity = entities;
                return this._applyFiltersForArray(((/** @type {?} */ (unkNowEntity))), filters, sort);
            })));
        }
    }
    /**
     * Create or update a filter
     * @param {?} filter
     * @return {?}
     */
    setFilter(filter) {
        if (this._server && isUndefined(typeof filter.server)) {
            filter.server = true;
        }
        /** @type {?} */
        const entity = createFilter(filter);
        this.filtersStore.upsert(entity.id, entity);
    }
    /**
     * Remove a Filter
     * @param {?} id
     * @return {?}
     */
    removeFilter(id) {
        this.filtersStore.remove(id);
    }
    /**
     * Clear all filters
     * @return {?}
     */
    clearFilters() {
        this.filtersStore.remove();
    }
    /**
     * Get filter value, return null, if value not available
     * @template T
     * @param {?} id
     * @return {?}
     */
    getFilterValue(id) {
        if (this.filtersQuery.hasEntity(id)) {
            /** @type {?} */
            const entity = this.filtersQuery.getEntity(id);
            return entity.value ? entity.value : null;
        }
        return null;
    }
    /**
     * Get filter value, return null, if value not available
     * @return {?}
     */
    getSortValue() {
        /** @type {?} */
        const state = this.filtersQuery.getValue();
        return state.sort ? state.sort : null;
    }
    /**
     * Select Sort by value
     * @return {?}
     */
    selectSortBy() {
        return this._selectSortBy$;
    }
    /**
     * Set orderBy
     * @param {?} order
     * @return {?}
     */
    setSortBy(order) {
        this.filtersStore.update({ sort: order });
    }
    /**
     * Get the filters normalized as key value or as query params.
     * This can be useful for server-side filtering
     * @param {?=} options
     * @return {?}
     */
    getNormalizedFilters(options = {}) {
        /** @type {?} */
        const result = {};
        options = Object.assign({ sortByKey: 'sortBy', sortByOrderKey: 'sortByOrder' }, options);
        for (const filter of this.getServerFilters()) {
            result[filter.id] = filter.value;
        }
        if (options.withSort) {
            /** @type {?} */
            const sort = this.getSortValue();
            result[options.sortByKey] = sort.sortBy;
            result[options.sortByOrderKey] = sort.sortByOrder;
        }
        if (options.asQueryParams) {
            return this._serialize(result);
        }
        return result;
    }
    /**
     * @return {?}
     */
    destroy() {
        this.clearFilters();
    }
    /**
     * This method is responsible for getting access to the query.
     * @protected
     * @return {?}
     */
    getQuery() {
        return this.query;
    }
    /**
     * This method is responsible for getting access to the store.
     * @protected
     * @return {?}
     */
    getStore() {
        return this.getQuery().__store__;
    }
    /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    _serialize(obj) {
        return Object.keys(obj)
            .map((/**
         * @param {?} k
         * @return {?}
         */
        k => `${encodeURIComponent(k)}=${encodeURIComponent(obj[k])}`))
            .join('&');
    }
    /**
     * @private
     * @param {?} entities
     * @param {?} filters
     * @param {?} sort
     * @return {?}
     */
    _applyFiltersForArray(entities, filters, sort) {
        /** @type {?} */
        let entitiesFiltered = entities;
        if (filters.length !== 0) {
            entitiesFiltered = entities.filter((/**
             * @param {?} entity
             * @param {?} index
             * @param {?} array
             * @return {?}
             */
            (entity, index, array) => {
                return filters.every((/**
                 * @param {?} filter
                 * @return {?}
                 */
                (filter) => {
                    if (filter.predicate) {
                        return !!filter.predicate(entity, index, array, filter);
                    }
                    return true;
                }));
            }));
        }
        if (sort && sort.sortBy) {
            /** @type {?} */
            const _sortBy = isFunction(sort.sortBy) ? sort.sortBy : compareValues(sort.sortBy, sort.sortByOrder);
            entitiesFiltered = [...entitiesFiltered.sort((/**
                 * @param {?} a
                 * @param {?} b
                 * @return {?}
                 */
                (a, b) => _sortBy(a, b, entities)))];
        }
        return entitiesFiltered;
    }
    /**
     * @private
     * @param {?} entities
     * @param {?} filters
     * @return {?}
     */
    _applyFiltersForHashMap(entities, filters) {
        if (filters.length === 0) {
            return entities;
        }
        /** @type {?} */
        const hashMapFiltered = {};
        Object.keys(entities).forEach((/**
         * @param {?} entityKey
         * @param {?} index
         * @return {?}
         */
        (entityKey, index) => {
            /** @type {?} */
            const entity = (/** @type {?} */ (entities[entityKey]));
            if (this._applyFiltersForOneEntity(filters, entity, index, entities)) {
                hashMapFiltered[entityKey] = entity;
            }
        }));
        return hashMapFiltered;
    }
    /**
     * @private
     * @param {?} filters
     * @param {?} entity
     * @param {?} index
     * @param {?} array
     * @return {?}
     */
    _applyFiltersForOneEntity(filters, entity, index, array) {
        return filters.every((/**
         * @param {?} filter
         * @return {?}
         */
        (filter) => {
            if (filter.predicate) {
                return !!filter.predicate(entity, index, array, filter);
            }
            return true;
        }));
    }
    /**
     * @protected
     * @param {?} id
     * @return {?}
     */
    instantiatePlugin(id) {
        return null;
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    AkitaFiltersPlugin.prototype._filtersStore;
    /**
     * @type {?}
     * @private
     */
    AkitaFiltersPlugin.prototype._filtersQuery;
    /**
     * @type {?}
     * @private
     */
    AkitaFiltersPlugin.prototype._server;
    /**
     * @type {?}
     * @private
     */
    AkitaFiltersPlugin.prototype._selectFilters$;
    /**
     * @type {?}
     * @private
     */
    AkitaFiltersPlugin.prototype._selectSortBy$;
    /**
     * @type {?}
     * @private
     */
    AkitaFiltersPlugin.prototype._selectFiltersAll$;
    /**
     * @type {?}
     * @protected
     */
    AkitaFiltersPlugin.prototype.query;
    /**
     * @type {?}
     * @private
     */
    AkitaFiltersPlugin.prototype.params;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template S, E
 */
class AkitaMatDataSource extends DataSource {
    /**
     * Data source to use an Akita EntityStore with a Material table
     * @see : https://material.angular.io/components/table/overview
     *
     * @param {?} query string : [Mandatory] the akita Query Entity, you wan to use to this data source.
     * @param {?=} akitaFilters string [Optional] If you want to provide an AkitaFilters that you use externally. Else it will create a new one.
     */
    constructor(query, akitaFilters) {
        super();
        this._paginator = null;
        this._sort = null;
        /**
         * Used to react to internal changes of the paginator that are made by the data source itself.
         */
        this._internalPageChanges = new Subject();
        /**
         * Stream emitting render data to the table (depends on ordered data changes).
         */
        this._renderData = new BehaviorSubject([]);
        /**
         * Used to react to internal changes of the paginator that are made by the data source itself.
         */
        this._disconnect = new Subject();
        /**
         * Subscription to the changes that should trigger an update to the table's rendered rows, such
         * as filtering, sorting, pagination, or base data changes.
         */
        this._renderChangesSubscription = Subscription.EMPTY;
        this._dataQuery = query;
        this._filters = akitaFilters ? akitaFilters : new AkitaFiltersPlugin(query);
        this._hasCustomFilters = !!akitaFilters;
        this._count$ = new BehaviorSubject(0);
        /** @type {?} */
        let count = 0;
        // @ts-ignore ignore, as without options, we will allways have an Array.
        this._selectAllByFilter$ = this._filters.selectAllByFilters();
        this._updateChangeSubscription();
    }
    /**
     * @param {?} searchQuery teh string use to search
     * @return {?}
     */
    set filter(searchQuery) {
        this.search = searchQuery;
    }
    /**
     * filter all the list by a search term.
     *
     * use like a property :
     * akitaMatDataSourceInstance.search = 'term';
     * @param {?} searchQuery the string use to search
     * @return {?}
     */
    set search(searchQuery) {
        if (searchQuery === '') {
            this._filters.removeFilter('search');
        }
        else {
            this._filters.setFilter({ id: 'search', value: searchQuery });
        }
    }
    /**
     * Instance of the MatSort directive used by the table to control its sorting. Sort changes
     * emitted by the MatSort will trigger an update to the table's rendered data.
     * @param {?} sort
     * @return {?}
     */
    set sort(sort) {
        this._sort = sort;
        sort.sortChange.pipe(takeUntil(this._disconnect)).subscribe((/**
         * @param {?} sortValue
         * @return {?}
         */
        (sortValue) => {
            this._filters.setSortBy({
                sortBy: (/** @type {?} */ (sortValue.active)),
                sortByOrder: sortValue.direction === 'desc' ? Order.DESC : Order.ASC
            });
        }));
        sort.initialized.subscribe((/**
         * @return {?}
         */
        () => {
            this.setDefaultSort((/** @type {?} */ (sort.active)), sort.direction === 'desc' ? Order.DESC : Order.ASC);
        }));
    }
    /**
     * Instance of the MatPaginator component used by the table to control what page of the data is
     * displayed. Page changes emitted by the MatPaginator will trigger an update to the
     * table's rendered data.
     *
     * Note that the data source uses the paginator's properties to calculate which page of data
     * should be displayed. If the paginator receives its properties as template inputs,
     * e.g. `[pageLength]=100` or `[pageIndex]=1`, then be sure that the paginator's view has been
     * initialized before assigning it to this data source.
     * @return {?}
     */
    get paginator() {
        return this._paginator;
    }
    /**
     * @param {?} paginator
     * @return {?}
     */
    set paginator(paginator) {
        this._paginator = paginator;
        this._updateChangeSubscription();
    }
    /**
     * @deprecated use get akitaFiltersPlugin
     * @return {?}
     */
    get AkitaFilters() {
        return this._filters;
    }
    /**
     * Access to AkitaFiltersPlugins, usefull to interact with all filters
     * @return {?}
     */
    get akitaFiltersPlugIn() {
        return this._filters;
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _updateCount(value) {
        /** @type {?} */
        const count = value.length ? value.length : 0;
        if (count !== this._count$.getValue()) {
            this._count$.next(count);
            this._updatePaginator(count);
        }
    }
    /**
     * Paginate the data (client-side). If you're using server-side pagination,
     * this would be replaced by requesting the appropriate data from the server.
     * @private
     * @param {?} data
     * @return {?}
     */
    _pageData(data) {
        this._updateCount(data);
        if (!this.paginator) {
            return data;
        }
        /** @type {?} */
        const startIndex = this.paginator.pageIndex * this.paginator.pageSize;
        return data.slice(startIndex, startIndex + this.paginator.pageSize);
    }
    /**
     *  add a filter to filters plugins
     * @param {?} filter
     * @return {?}
     */
    addFilter(filter) {
        this._filters.setFilter(filter);
    }
    /**
     *  add a filter to filters plugins
     * @param {?} filter
     * @return {?}
     */
    setFilter(filter) {
        this._filters.setFilter(filter);
    }
    /**
     * Remove a AkitaFilter
     * @param {?} id
     * @return {?}
     */
    removeFilter(id) {
        this._filters.removeFilter(id);
    }
    /**
     * Clear all filters
     * @return {?}
     */
    clearFilters() {
        this._filters.clearFilters();
    }
    /**
     * Get filter value, return null, if value not available
     * @template V
     * @param {?} id
     * @return {?}
     */
    getFilterValue(id) {
        return this._filters.getFilterValue(id);
    }
    /**
     * Set the default sort
     * @param {?} sortColumn the colum name present in your object
     * @param {?=} direction string the direction for sorting (asc or desc). Default asc.
     * @return {?}
     */
    setDefaultSort(sortColumn, direction = 'asc') {
        this._filters.setSortBy({
            sortBy: sortColumn,
            sortByOrder: direction === 'desc' ? Order.DESC : Order.ASC
        });
    }
    /**
     * Select Count filtered results.
     * @return {?}
     */
    selectCount() {
        return this._count$.asObservable();
    }
    /**
     * Select Count filtered results.
     * @return {?}
     */
    getCount() {
        return this._count$.getValue();
    }
    /**
     * Subscribe to changes that should trigger an update to the table's rendered rows. When the
     * changes occur, process the current state of the filter, sort, and pagination along with
     * the provided base data and send it to the table for rendering.
     * @return {?}
     */
    _updateChangeSubscription() {
        // Sorting and/or pagination should be watched if MatSort and/or MatPaginator are provided.
        // The events should emit whenever the component emits a change or initializes, or if no
        // component is provided, a stream with just a null event should be provided.
        // The `sortChange` and `pageChange` acts as a signal to the combineLatests below so that the
        // pipeline can progress to the next step. Note that the value from these streams are not used,
        // they purely act as a signal to progress in the pipeline.
        // Sorting and/or pagination should be watched if MatSort and/or MatPaginator are provided.
        // The events should emit whenever the component emits a change or initializes, or if no
        // component is provided, a stream with just a null event should be provided.
        // The `sortChange` and `pageChange` acts as a signal to the combineLatests below so that the
        // pipeline can progress to the next step. Note that the value from these streams are not used,
        // they purely act as a signal to progress in the pipeline.
        /** @type {?} */
        const pageChange = this._paginator ?
            (/** @type {?} */ (merge(this._paginator.page, this._internalPageChanges, this._paginator.initialized))) :
            of(null);
        /** @type {?} */
        const paginatedData = combineLatest(this._selectAllByFilter$, pageChange)
            .pipe(map((/**
         * @param {?} __0
         * @return {?}
         */
        ([data]) => this._pageData(data))));
        // Watched for paged data changes and send the result to the table to render.
        this._renderChangesSubscription.unsubscribe();
        this._renderChangesSubscription = paginatedData.pipe(takeUntil(this._disconnect)).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => this._renderData.next(data)));
        this._internalPageChanges.next();
    }
    /**
     * Updates the paginator to reflect the length of the filtered data, and makes sure that the page
     * index does not exceed the paginator's last page. Values are changed in a resolved promise to
     * guard against making property changes within a round of change detection.
     * @param {?} filteredDataLength
     * @return {?}
     */
    _updatePaginator(filteredDataLength) {
        Promise.resolve().then((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const paginator = this.paginator;
            if (!paginator) {
                return;
            }
            paginator.length = filteredDataLength;
            // If the page index is set beyond the page, reduce it to the last page.
            if (paginator.pageIndex > 0) {
                /** @type {?} */
                const lastPageIndex = Math.ceil(paginator.length / paginator.pageSize) - 1 || 0;
                /** @type {?} */
                const newPageIndex = Math.min(paginator.pageIndex, lastPageIndex);
                if (newPageIndex !== paginator.pageIndex) {
                    paginator.pageIndex = newPageIndex;
                    // Since the paginator only emits after user-generated changes,
                    // we need our own stream so we know to should re-render the data.
                    this._internalPageChanges.next();
                }
            }
        }));
    }
    /**
     * Function used by matTable to subscribe to the data
     * @return {?}
     */
    connect() {
        return this._renderData;
    }
    /**
     * Used by the MatTable. Called when it is destroyed. No-op.
     * \@docs-private
     * @return {?}
     */
    disconnect() {
        if (!this._hasCustomFilters) {
            this._filters.clearFilters();
            this._filters.destroy();
        }
        this._disconnect.next();
        this._disconnect.complete();
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    AkitaMatDataSource.prototype._dataQuery;
    /**
     * @type {?}
     * @private
     */
    AkitaMatDataSource.prototype._filters;
    /**
     * if set a custom filter plugins, do not delete all in disconnect() *
     * @type {?}
     * @private
     */
    AkitaMatDataSource.prototype._hasCustomFilters;
    /**
     * @type {?}
     * @private
     */
    AkitaMatDataSource.prototype._paginator;
    /**
     * @type {?}
     * @private
     */
    AkitaMatDataSource.prototype._sort;
    /**
     * @type {?}
     * @private
     */
    AkitaMatDataSource.prototype._selectAllByFilter$;
    /**
     * @type {?}
     * @private
     */
    AkitaMatDataSource.prototype._count$;
    /**
     * Used to react to internal changes of the paginator that are made by the data source itself.
     * @type {?}
     * @private
     */
    AkitaMatDataSource.prototype._internalPageChanges;
    /**
     * Stream emitting render data to the table (depends on ordered data changes).
     * @type {?}
     * @private
     */
    AkitaMatDataSource.prototype._renderData;
    /**
     * Used to react to internal changes of the paginator that are made by the data source itself.
     * @type {?}
     * @private
     */
    AkitaMatDataSource.prototype._disconnect;
    /**
     * Subscription to the changes that should trigger an update to the table's rendered rows, such
     * as filtering, sorting, pagination, or base data changes.
     * @type {?}
     */
    AkitaMatDataSource.prototype._renderChangesSubscription;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AkitaFiltersPlugin, AkitaFiltersQuery, AkitaFiltersStore, AkitaMatDataSource, createFilter, defaultFilter, searchFilter, searchFilterIn };
//# sourceMappingURL=akita-filters-plugin.js.map
